extern crate header;
use header::vbft_block_info::*;
use header::*;

extern crate hex;

use elrond_wasm::elrond_codec::*;
use zero_copy_source::ZeroCopySource;

#[test]
fn test_header_deserialization() {
    let input = "0100000000FFFFFFFFFFFFFF7F721ADAF73AAEDEE422B623581572078E895F7A47B63999B301D8A78C67EBF1FEC31614565201089BF5C639D923EBFC63541C91522B8C29B0FF605BEBAC309B0E0000000000000000000000000000000000000000000000000000000000000000E7F41653FDAF63C4366DB84674AF2B614FCC40D5F37AF5AF4CCFAD543FB318BC94BD3A5F60EA0000BBCB0265FA485DC6FD7804010000004104C143BE3BD9216ED6BB16DA1D1F9E86C933D66066F195A9787ED787349FDBB28A8EEFE090391539EC512B50749A6D76FA1E80BB405DF7D73C39CE462BC0B15D7B404C0F9FBB0C7864ACA426B22D7357A16035ECAC127987F1C02060C705AC6852274DBD5E1E31DEE1084D97AF8F95126004F56D88DA1E079F9C8B8C93A01D7EDA8160EA00000100000002000000070000000200000000E40B540200000000E40B540200000000E40B54020000000700000000000000010000004631323035303365663434626562613834343232626437366135393935333163396665353039363961393239613066656533356466363636393066333730636531396661386330060000004631323035303361346634346464363563626363353262316431616335313734373337386137663834373533623566376266323736306361323133393063656436623137326262020000004631323035303338323437656663666561653066646637363036383564316163316330383362653366663565396134613534386263336132653938663034333466303932343833050000004631323035303264306430653838336337336438323536636634333134383232646464393733633031373962373364386564336466383561616433386433366138623262306337040000004631323035303237626437373165363861646238383339383238326532316138623033633132663634633233353165613439613262613036613033323763383362323339636139070000004631323035303236393663306362653734663031656538356533633065626534656264633562656134303466313939643032363266313934316664333966663064313030323537030000004631323035303232303932653334653031373664636366386162623439366238333364353931643235353333343639623363616630653237396239373432393535646438666333690000000000000002000000060000000200000002000000010000000500000005000000070000000700000003000000060000000300000005000000040000000300000005000000030000000600000005000000060000000600000001000000040000000200000006000000050000000300000007000000030000000700000003000000060000000100000004000000010000000600000006000000020000000400000005000000010000000100000001000000070000000500000004000000030000000300000003000000050000000400000001000000040000000400000002000000040000000100000002000000020000000100000004000000060000000500000004000000040000000600000005000000070000000700000006000000030000000200000002000000050000000500000003000000070000000700000007000000020000000300000003000000070000000700000007000000010000000100000003000000010000000700000005000000020000000100000004000000060000000200000004000000010000000200000006000000020000000500000004000000060000000700000060EA00003CC22B9403D96EE5C9422CA9D502E0907617CCB2";
    let serialized = hex::decode(input).expect("hex decoding failed");
    let _header = match Header::dep_decode(&mut serialized.as_slice()) {
        Ok(h) => h,
        Err(err) => panic!(
            "Header deserialization error: {}",
            std::str::from_utf8(&err.message_bytes()).unwrap()
        ),
    };
}

#[test]
fn test_consensus_payload_deserialization() {
    let input = "";
    let serialized = hex::decode(input).expect("hex decoding failed");
    let mut source = ZeroCopySource::new(&serialized);
    let _payload = match VbftBlockInfo::decode_from_source(&mut source, true) {
        Ok(p) => p,
        Err(err) => panic!(
            "Consensus payload decoding error: {}",
            std::str::from_utf8(&err.message_bytes()).unwrap()
        ),
    };
}
